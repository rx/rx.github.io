---
layout: post
title: Rails exception handling - Egregious
date: '2011-09-27T09:45:00.000-07:00'
author: Rx
tags: 
modified_time: '2015-10-23T08:40:54.210-07:00'
blogger_id: tag:blogger.com,1999:blog-3950436325253663978.post-5977641490449370728
blogger_orig_url: http://railsindirection.blogspot.com/2011/09/rails-exception-handling-egregious.html
---

Version 0.2.9 released to https://rubygems.org/gems/egregious on 10.23.2015<br />&nbsp;
      &nbsp; &nbsp; &nbsp; Added support for exceptions that define a http_status. The exception map can
      override this.<br />&nbsp; &nbsp; &nbsp; &nbsp; This is a good way to allow a raise to
      specify a http_status using a custom exception.<br />&nbsp; &nbsp; &nbsp; &nbsp; The idea
      for this came from the Stripe::Error exception classes.<br />&nbsp; &nbsp; &nbsp; &nbsp;
      Also updated Gemfile.lock to ruby 2.2.1 and latest dependencies. This is for specs only.<br /><div><br
      /></div>Egregious is a rails based exception handling gem for well defined http exception handling for
      json, xml and html.<br /><br />If you have a json or xml api into your rails application, you probably
      have added your own exception handling to map exceptions to a http status and formatting your json and xml output.
      <br /><br />You probably have code sprinkled about like this:<br /><pre class="ruby"
      name="code">rescue_from CanCan::AccessDenied do |exception|<br /> flash[:alert] = exception.message<br
      /> respond_to do |format|<br /> format.html { redirect_to dashboard_path }<br /> format.xml {
      render :xml =&gt; exception.to_xml, :status =&gt; :forbidden }<br /> format.json { render :json=&gt;
      exception.to_json, :status =&gt; :forbidden }<br /> end<br /> end</pre><br />This
      example is straight from the CanCan docs. You'll notice a couple of things here. This handles the
      CanCan::AccessDenied exception only. It then will redirect to the startup page, or render xml and json returning
      the http status code of :forbidden (403). You can see one of the first features of the Egregious gem. We extend
      Exception to add the to_xml and to_json methods. These return a well structured error that can be consumed by the
      API client.<br /><pre class="ruby" name="code">Exception.new("Hi Mom").to_xml</pre><br />returns:
      <br /><pre class="ruby" name="code">"<errors><error>Hi Mom</error><type>Exception</type></errors>"</pre><br
      /><pre class="ruby" name="code">Exception.new("Hi Dad").to_json</pre><br />returns: <br /><pre
      class="ruby" name="code">"{\"error\":\"Hi Dad\", \"type\":\"Exception\"}"</pre><br />So that's
      pretty handy in itself. Now all exceptions have a json and xml api that describe them. It happens to be the same
      xml and json that is returned from the errors active record object, with the addition of the type element. That
      allows you to mix and match validations and exceptions. Wow, big deal. We'll it is. If you are writing a client
      then you need to have a very well defined error handling. I'd like to see all of rails do this by default. So that
      anyone interacting with a rails resource has a consistent error handling experience. (Expect more on being a good
      REST API in future posts.) As a client we can now handle errors in a consistent way.<br /><br />Besides
      the error message we would like a well defined mapping of classes of exceptions to http status codes. The idea is
      that if I get back a specific http status code then I can program against that 'class' of problems. For example if
      I know that what I did was because of invalid input from my user, I can display that message back to the user.
      They can correct it and continue down the path. But if the Http status code says that it was a problem with the
      server, then I know that I need to log it and notify someone to see how to resolve it.<br /><br />We
      handle all exceptions of a given class with a mapping to an http status code. With all the most common Ruby,
      Rails, Devise, Warden and CanCan exceptions having reasonable defaults. (Devise, Warden and CanCan are all
      optional and ignored if their gems are not installed.)<br /><br />As of 0.2.9 you can also define a
      method named 'http_status' on the exception and it will be used as the status code. This is a nice pattern that
      allows you to raise an exception and specify the status code. The Egregious::Error allows you to do this as a
      second parameter to initialize:<br /><pre class="ruby" name="code"><br /> raise
      Egregious::Error.new("My very bad error", :payment_required)<br /></pre><br /> If the problem
      was the api caller then the result codes are in the 300 range. If the problem was on the server then the status
      codes are in the 500 range. <br /><br />I'm guessing if you bother to read this far, you are probably
      interested in using Egregious. Its simple to use and configure. To install:<br /><br />In you Gemfile
      add the following:<br /><pre class="ruby" name="code">gem 'egregious'</pre><br /><br />In
      your ApplicationController class add the following at or near the top:<br /><pre class="ruby" name="code">class
      ApplicationController &lt; ActionController::Base<br /> include Egregious<br />
      protect_from_forgery<br />end<br /></pre><br /><br />That's it. You will now get
      reasonable api error handling.<br /><br />If you want to add your own exceptions to http status codes
      mappings, or change the defaults add an initializer and put the following into it:<br /><pre class="ruby"
      name="code">Egregious.exception_codes.merge!({NameError =&gt; :bad_request})</pre><br />Here
      you can re-map anything and you can add new mappings. <br /><br />Note: If you think the default
      exception mappings should be different, please contact me via the <a
      href="https://github.com/voomify/egregious">Egregious github project</a>.<br /><br />We also
      created exceptions for each of the http status codes, so that you can throw those exceptions in your code. Its an
      easy way to throw the right status code and setup a good message for it. If you want to provide more context, you
      can derive you own exceptions and add mappings for them.<br /><br />Here is an example of throwing a
      bad request exception: <br /><pre class="ruby" name="code">raise Egregious::BadRequest.new("You can
      not created an order without a customer.") unless customer_id</pre><br /><br />Egregious adds
      mapping of many exceptions, if you have your own rescue_from handlers those will get invoked. You will not lose
      any existing behavior, but you also might not see the changes you expect until you remove or modify those
      rescue_from calls. At a minimum I suggest using the .to_xml and .to_json calls io your existing rescue_from
      methods/blocks.<br /><br />And finally if you don't like the default behavior. You can override any
      portion of it and change it to meet your needs.<br /><br />If you want to change the behavior then you
      can override the following methods in your ApplicationController.<br /><pre class="ruby" name="code">#
      override this if you want your flash to behave differently<br />def egregious_flash(exception)<br />
      flash.now[:alert] = exception.message<br />end</pre><br /><br /><pre class="ruby"
      name="code"># override this if you want your logging to behave differently<br />def
      egregious_log(exception)<br /> logger.fatal(<br /> "\n\n" + exception.class.to_s + ' (' +
      exception.message.to_s + '):\n ' +<br /> clean_backtrace(exception).join("\n ") +<br /> "\n\n")<br
      /> HoptoadNotifier.notify(exception) if defined?(HoptoadNotifier)<br />end</pre><br /><br
      /><pre class="ruby" name="code"># override this if you want to change your respond_to behavior<br />def
      egregious_respond_to(exception)<br /> respond_to do |format|<br /> status =
      status_code_for_exception(exception)<br /> format.xml { render :xml=&gt; exception.to_xml, :status =&gt;
      status }<br /> format.json { render :json=&gt; exception.to_json, :status =&gt; status }<br />
      # render the html page for the status we are returning it exists...if not then render the 500.html page.<br />
      format.html { render :file =&gt; File.exists?(build_html_file_path(status)) ?<br />
      build_html_file_path(status) : build_html_file_path('500')}<br /> end<br />end</pre><br /><br
      /><pre class="ruby" name="code"># override this if you want to change what html static file gets
      returned.<br />def build_html_file_path(status)<br /> File.expand_path(Rails.root, 'public', status +
      '.html')<br />end</pre><br /><br /><pre class="ruby" name="code"># override this if
      you want to control what gets sent to airbrake<br /># optionally you can configure the airbrake ignore list<br
      />def notify_airbrake(exception)<br /> # for ancient clients - can probably remove<br />
      HoptoadNotifier.notify(exception) if defined?(HoptoadNotifier)<br /> # tested with airbrake 3.1.15 and 4.2.1<br
      /> env['airbrake.error_id'] = Airbrake.notify_or_ignore(exception) if defined?(Airbrake)<br />end</pre><br
      /><br />We are using this gem in all our Rails projects.<br /><br />Go forth and be
      egregious!
    